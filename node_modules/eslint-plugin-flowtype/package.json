{
  "_args": [
    [
      {
        "raw": "eslint-plugin-flowtype@2.21.0",
        "scope": null,
        "escapedName": "eslint-plugin-flowtype",
        "name": "eslint-plugin-flowtype",
        "rawSpec": "2.21.0",
        "spec": "2.21.0",
        "type": "version"
      },
      "/Users/owner/wdi/wingIt/node_modules/react-scripts"
    ]
  ],
  "_from": "eslint-plugin-flowtype@2.21.0",
  "_id": "eslint-plugin-flowtype@2.21.0",
  "_inCache": true,
  "_location": "/eslint-plugin-flowtype",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/eslint-plugin-flowtype-2.21.0.tgz_1477131355257_0.7500109609682113"
  },
  "_npmUser": {
    "name": "gajus",
    "email": "gajus@gajus.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "eslint-plugin-flowtype@2.21.0",
    "scope": null,
    "escapedName": "eslint-plugin-flowtype",
    "name": "eslint-plugin-flowtype",
    "rawSpec": "2.21.0",
    "spec": "2.21.0",
    "type": "version"
  },
  "_requiredBy": [
    "/react-scripts"
  ],
  "_resolved": "https://registry.npmjs.org/eslint-plugin-flowtype/-/eslint-plugin-flowtype-2.21.0.tgz",
  "_shasum": "a47e85abcdd181d37a336054bd552149ae387d9c",
  "_shrinkwrap": null,
  "_spec": "eslint-plugin-flowtype@2.21.0",
  "_where": "/Users/owner/wdi/wingIt/node_modules/react-scripts",
  "author": {
    "name": "Gajus Kuizinas",
    "email": "gajus@gajus.com",
    "url": "http://gajus.com"
  },
  "bugs": {
    "url": "https://github.com/gajus/eslint-plugin-flowtype/issues"
  },
  "dependencies": {
    "lodash": "^4.15.0"
  },
  "description": "Flowtype linting rules for ESLint.",
  "devDependencies": {
    "babel-cli": "^6.14.0",
    "babel-eslint": "^6.1.2",
    "babel-plugin-add-module-exports": "^0.2.1",
    "babel-preset-es2015": "^6.14.0",
    "babel-preset-stage-0": "^6.5.0",
    "babel-register": "^6.14.0",
    "chai": "^3.5.0",
    "conventional-changelog-lint": "^1.0.1",
    "create-index": "^0.1.3",
    "eslint": "^3.4.0",
    "eslint-config-canonical": "1.8.1",
    "gitdown": "^2.5.0",
    "husky": "^0.11.7",
    "jsonlint": "^1.6.2",
    "mocha": "^3.0.2",
    "standard-version": "^2.4.0",
    "travis-after-all": "^1.4.4"
  },
  "directories": {},
  "dist": {
    "shasum": "a47e85abcdd181d37a336054bd552149ae387d9c",
    "tarball": "https://registry.npmjs.org/eslint-plugin-flowtype/-/eslint-plugin-flowtype-2.21.0.tgz"
  },
  "gitHead": "b22a29d0fceafdeecbff63c1de69c6032c1a2f28",
  "homepage": "https://github.com/gajus/eslint-plugin-flowtype#readme",
  "keywords": [
    "eslint",
    "plugin",
    "flowtype"
  ],
  "license": "BSD-3-Clause",
  "main": "./dist/index.js",
  "maintainers": [
    {
      "name": "gajus",
      "email": "gajus@gajus.com"
    }
  ],
  "name": "eslint-plugin-flowtype",
  "optionalDependencies": {},
  "peerDependencies": {
    "eslint": ">=2.0.0"
  },
  "readme": "<a name=\"eslint-plugin-flowtype\"></a>\n# eslint-plugin-flowtype\n\n[![NPM version](http://img.shields.io/npm/v/eslint-plugin-flowtype.svg?style=flat-square)](https://www.npmjs.org/package/eslint-plugin-flowtype)\n[![Travis build status](http://img.shields.io/travis/gajus/eslint-plugin-flowtype/master.svg?style=flat-square)](https://travis-ci.org/gajus/eslint-plugin-flowtype)\n[![js-canonical-style](https://img.shields.io/badge/code%20style-canonical-blue.svg?style=flat-square)](https://github.com/gajus/canonical)\n\n[Flow type](http://flowtype.org/) linting rules for ESLint.\n\n* [eslint-plugin-flowtype](#eslint-plugin-flowtype)\n    * [Installation](#eslint-plugin-flowtype-installation)\n    * [Configuration](#eslint-plugin-flowtype-configuration)\n        * [Shareable configurations](#eslint-plugin-flowtype-configuration-shareable-configurations)\n    * [Settings](#eslint-plugin-flowtype-settings)\n        * [`onlyFilesWithFlowAnnotation`](#eslint-plugin-flowtype-settings-onlyfileswithflowannotation)\n    * [Rules](#eslint-plugin-flowtype-rules)\n        * [`boolean-style`](#eslint-plugin-flowtype-rules-boolean-style)\n        * [`define-flow-type`](#eslint-plugin-flowtype-rules-define-flow-type)\n        * [`delimiter-dangle`](#eslint-plugin-flowtype-rules-delimiter-dangle)\n        * [`generic-spacing`](#eslint-plugin-flowtype-rules-generic-spacing)\n        * [`no-dupe-keys`](#eslint-plugin-flowtype-rules-no-dupe-keys)\n        * [`no-weak-types`](#eslint-plugin-flowtype-rules-no-weak-types)\n        * [`require-parameter-type`](#eslint-plugin-flowtype-rules-require-parameter-type)\n        * [`require-return-type`](#eslint-plugin-flowtype-rules-require-return-type)\n        * [`require-valid-file-annotation`](#eslint-plugin-flowtype-rules-require-valid-file-annotation)\n        * [`semi`](#eslint-plugin-flowtype-rules-semi)\n        * [`sort-keys`](#eslint-plugin-flowtype-rules-sort-keys)\n        * [`space-after-type-colon`](#eslint-plugin-flowtype-rules-space-after-type-colon)\n        * [`space-before-generic-bracket`](#eslint-plugin-flowtype-rules-space-before-generic-bracket)\n        * [`space-before-type-colon`](#eslint-plugin-flowtype-rules-space-before-type-colon)\n        * [`type-id-match`](#eslint-plugin-flowtype-rules-type-id-match)\n        * [`union-intersection-spacing`](#eslint-plugin-flowtype-rules-union-intersection-spacing)\n        * [`use-flow-type`](#eslint-plugin-flowtype-rules-use-flow-type)\n        * [`valid-syntax`](#eslint-plugin-flowtype-rules-valid-syntax)\n\n\n<a name=\"eslint-plugin-flowtype-installation\"></a>\n## Installation\n\n1. Install [ESLint](https://www.github.com/eslint/eslint).\n1. Install [`babel-eslint`](https://github.com/babel/babel-eslint) parser (ESLint parser [does not support type annotations](https://github.com/eslint/eslint/issues/2157)).\n1. Install [`eslint-plugin-flowtype`](https://github.com/gajus/eslint-plugin-flowtype) plugin.\n\n<!-- -->\n\n```sh\nnpm install eslint\nnpm install babel-eslint\nnpm install eslint-plugin-flowtype\n```\n\n<a name=\"eslint-plugin-flowtype-configuration\"></a>\n## Configuration\n\n1. Set `parser` property to `babel-eslint`.\n1. Add `plugins` section and specify `eslint-plugin-flowtype` as a plugin.\n1. Enable rules.\n\n<!-- -->\n\n```json\n{\n  \"parser\": \"babel-eslint\",\n  \"plugins\": [\n    \"flowtype\"\n  ],\n  \"rules\": {\n    \"flowtype/boolean-style\": [\n      2,\n      \"boolean\"\n    ],\n    \"flowtype/define-flow-type\": 1,\n    \"flowtype/delimiter-dangle\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/generic-spacing\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/no-weak-types\": 2,\n    \"flowtype/require-parameter-type\": 2,\n    \"flowtype/require-return-type\": [\n      2,\n      \"always\",\n      {\n        \"annotateUndefined\": \"never\"\n      }\n    ],\n    \"flowtype/require-valid-file-annotation\": 2,\n    \"flowtype/semi\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/space-after-type-colon\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/space-before-generic-bracket\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/space-before-type-colon\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/type-id-match\": [\n      2,\n      \"^([A-Z][a-z0-9]+)+Type$\"\n    ],\n    \"flowtype/union-intersection-spacing\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/use-flow-type\": 1,\n    \"flowtype/valid-syntax\": 1\n  },\n  \"settings\": {\n    \"flowtype\": {\n      \"onlyFilesWithFlowAnnotation\": false\n    }\n  }\n}\n```\n\n<a name=\"eslint-plugin-flowtype-configuration-shareable-configurations\"></a>\n### Shareable configurations\n\n<a name=\"eslint-plugin-flowtype-configuration-shareable-configurations-recommended\"></a>\n#### Recommended\n\nThis plugin exports a [recommended configuration](./src/configs/recommended.json) that enforces Flow type good practices.\n\nTo enable this configuration use the extends property in your `.eslintrc` config file:\n\n```json\n{\n  \"extends\": [\n    \"plugin:flowtype/recommended\"\n  ],\n  \"plugins\": [\n    \"flowtype\"\n  ]\n}\n```\n\nSee [ESLint documentation](http://eslint.org/docs/user-guide/configuring#extending-configuration-files) for more information about extending configuration files.\n\n<a name=\"eslint-plugin-flowtype-settings\"></a>\n## Settings\n\n<a name=\"eslint-plugin-flowtype-settings-onlyfileswithflowannotation\"></a>\n### <code>onlyFilesWithFlowAnnotation</code>\n\nWhen `true`, only checks files with a [`@flow` annotation](http://flowtype.org/docs/about-flow.html#gradual) in the first comment.\n\n```js\n{\n  \"settings\": {\n    \"flowtype\": {\n      \"onlyFilesWithFlowAnnotation\": true\n    }\n  }\n}\n```\n\n<a name=\"eslint-plugin-flowtype-rules\"></a>\n## Rules\n\n<!-- Rules are sorted alphabetically. -->\n\n<a name=\"eslint-plugin-flowtype-rules-boolean-style\"></a>\n### <code>boolean-style</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces a particular style for boolean type annotations. This rule takes one argument.\n\nIf it is `'boolean'` then a problem is raised when using `bool` instead of `boolean`.\n\nIf it is `'bool'` then a problem is raised when using `boolean` instead of `bool`.\n\nThe default value is `'boolean'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = bool\n// Message: Use \"boolean\", not \"bool\"\n\n// Options: [\"boolean\"]\ntype X = bool\n// Message: Use \"boolean\", not \"bool\"\n\n// Options: [\"bool\"]\ntype X = boolean\n// Message: Use \"bool\", not \"boolean\"\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = boolean\n\n// Options: [\"boolean\"]\ntype X = boolean\n\n// Options: [\"bool\"]\ntype X = bool\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-define-flow-type\"></a>\n### <code>define-flow-type</code>\n\nMarks Flow type identifiers as defined.\n\nUsed to suppress [`no-undef`](http://eslint.org/docs/rules/no-undef) reporting of type identifiers.\n\nThe following patterns are not considered problems:\n\n```js\nvar a: AType\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType; var b: AType\n// Additional rules: {\"no-undef\":2}\n\nvar a; (a: AType)\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType<BType>\n// Additional rules: {\"no-undef\":2}\n\ntype A = AType\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType.a) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType.a.b) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a): AType {}; var a: AType\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a): AType {}\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType }\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType.a }\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType.a.b }\n// Additional rules: {\"no-undef\":2}\n\nclass C implements AType {}\n// Additional rules: {\"no-undef\":2}\n\ninterface AType {}\n// Additional rules: {\"no-undef\":2}\n\n({ a: ({b() {}}: AType) })\n// Additional rules: {\"no-undef\":2}\n\ntype X = {Y<AType>(): BType}\n// Additional rules: {\"no-undef\":2}\n\ninterface AType<BType> {}\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a: AType; var b: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a; (a: AType)\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a: AType<BType>\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ntype A = AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType.a) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType.a.b) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a): AType {}; var a: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a): AType {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType.a }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType.a.b }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C implements AType {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ninterface AType {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\n({ a: ({b() {}}: AType) })\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ntype X = {Y<AType>(): BType}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ninterface AType<BType> {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-delimiter-dangle\"></a>\n### <code>delimiter-dangle</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent use of trailing commas in Object and Tuple annotations.\n\nThis rule takes one argument which mirrors ESLint's default `comma-dangle` rule.\n\nIf it is `'never'` then a problem is raised when there is a trailing comma.\n\nIf it is `'always'` then a problem is raised when there is no trailing comma.\n\nIf it is `'always-multiline'` then a problem is raised when there is no trailing comma on a multi-line definition, or there _is_ a trailing comma on a single-line definition.\n\nIf it is `'only-multiline'` then a problem is raised when there is a trailing comma on a single-line definition. It allows, but does not enforce, trailing commas on multi-line definitions.\n\nThe default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\nfoo: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = {\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\n[key: string]: number,\naReallyLongPropertyNameHere: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, foo: string }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = {\n[key: string]: number;\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string, [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\naReallyLongPropertyNameHere: string,\n[key: string]: number,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string, [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string; [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string, [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = [\nstring,\nnumber,\n]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = [string, number]\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = [\nstring,\nnumber\n]\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = [\nfoo, string\n]\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = [ number, string, ]\n// Message: Unexpected trailing delimiter\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = { foo: string }\n\n// Options: [\"never\"]\ntype X = { foo: string }\n\n// Options: [\"always\"]\ntype X = { foo: string, }\n\n// Options: [\"always\"]\ntype X = { foo: string; }\n\n// Options: [\"never\"]\ntype X = {\nfoo: string\n}\n\n// Options: [\"always\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string }\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string;\n}\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string }\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string;\n}\n\n// Options: [\"never\"]\ntype X = {}\n\n// Options: [\"always\"]\ntype X = {}\n\n// Options: [\"always-multiline\"]\ntype X = {}\n\n// Options: [\"only-multiline\"]\ntype X = {}\n\n// Options: [\"never\"]\ntype X = { [key: string]: number }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number; }\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number }\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number\n}\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number }\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, foo: string, }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number; foo: string; }\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number;\nfoo: string\n}\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"never\"]\ntype X = { foo: string, [key: string]: number }\n\n// Options: [\"always\"]\ntype X = { foo: string, [key: string]: number, }\n\n// Options: [\"always\"]\ntype X = { foo: string; [key: string]: number; }\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, [key: string]: number }\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string;\n[key: string]: number\n}\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string, [key: string]: number }\n\ntype X = [string, number]\n\n// Options: [\"never\"]\ntype X = [string, number]\n\n// Options: [\"never\"]\ntype X = [\nstring,\nnumber\n]\n\n// Options: [\"always\"]\ntype X = [string, number,]\n\n// Options: [\"always\"]\ntype X = [\nstring,\nnumber,\n]\n\n// Options: [\"always-multiline\"]\ntype X = [ foo, string ]\n\n// Options: [\"always-multiline\"]\ntype X = [\nfoo, string,\n]\n\n// Options: [\"only-multiline\"]\ntype X = [ number, string ]\n\n// Options: [\"only-multiline\"]\ntype X = [\nnumber,\nstring\n]\n\n// Options: [\"only-multiline\"]\ntype X = [\nnumber,\nstring,\n]\n\n// Options: [\"never\"]\ntype X = []\n\n// Options: [\"always\"]\ntype X = []\n\n// Options: [\"always-multiline\"]\ntype X = []\n\n// Options: [\"only-multiline\"]\ntype X = []\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-generic-spacing\"></a>\n### <code>generic-spacing</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing within generic type annotation parameters.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a space surrounding the generic type parameters. If it is `'always'` then a problem is raised when there is no space surrounding the generic type parameters.\n\nThe default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = Promise< string>\n// Message: There must be no space at start of \"Promise\" generic type annotation\n\n// Options: [\"never\"]\ntype X = Promise<  string>\n// Message: There must be no space at start of \"Promise\" generic type annotation\n\ntype X = FooBar<string >\n// Message: There must be no space at end of \"FooBar\" generic type annotation\n\ntype X = Promise< string >\n// Message: There must be no space at start of \"Promise\" generic type annotation\n// Message: There must be no space at end of \"Promise\" generic type annotation\n\ntype X = Promise< (foo), bar, (((baz))) >\n// Message: There must be no space at start of \"Promise\" generic type annotation\n// Message: There must be no space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<string >\n// Message: There must be a space at start of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar< string>\n// Message: There must be a space at end of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<string>\n// Message: There must be a space at start of \"Promise\" generic type annotation\n// Message: There must be a space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<(foo), bar, (((baz)))>\n// Message: There must be a space at start of \"Promise\" generic type annotation\n// Message: There must be a space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar<  string >\n// Message: There must be one space at start of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar< string  >\n// Message: There must be one space at end of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<  (foo), bar, (((baz)))  >\n// Message: There must be one space at start of \"Promise\" generic type annotation\n// Message: There must be one space at end of \"Promise\" generic type annotation\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Promise<string>\n\ntype X = Promise<(string)>\n\ntype X = Promise<(foo), bar, (((baz)))>\n\n// Options: [\"always\"]\ntype X = Promise< string >\n\n// Options: [\"always\"]\ntype X = Promise< (string) >\n\n// Options: [\"always\"]\ntype X = Promise< (foo), bar, (((baz))) >\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-dupe-keys\"></a>\n### <code>no-dupe-keys</code>\n\nChecks for duplicate properties in Object annotations.\n\nThis rule mirrors ESLint's [no-dupe-keys](http://eslint.org/docs/rules/no-dupe-keys) rule.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-dupe-keys\": 2\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype FooType = { a: number, b: string, a: number }\n// Message: Duplicate property.\n\ntype FooType = { a: number, b: string, a: string }\n// Message: Duplicate property.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = { a: number, b: string, c: number }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-weak-types\"></a>\n### <code>no-weak-types</code>\n\nWarns against weak type annotations *any*, *Object* and *Function*.\nThese types can cause flow to silently skip over portions of your code,\nwhich would have otherwise caused type errors.\n\nThis rule optionally takes one argument, an object to configure which type warnings to enable. By default, all of the\nwarnings are enabled. e.g. to disable the `any` warning (allowing it to exist in your code), while continuing to warn\nabout `Object` and `Function`:\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-weak-types\": [2, {\n            \"any\": false,\n            \"Object\": true,\n            \"Function\": true\n        }]\n    }\n}\n\n// or, the following is equivalent as default is true:\n\n{\n    \"rules\": {\n        \"flowtype/no-weak-types\": [2, {\n            \"any\": false\n        }]\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\nfunction foo(thing): any {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Promise<any> {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Promise<Promise<any>> {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Object {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Promise<Object> {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Promise<Promise<Object>> {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Function {}\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing): Promise<Function> {}\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing): Promise<Promise<Function>> {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo: any) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo: Function) => {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo?: any) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo?: Function) => {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo: { a: any }) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo: { a: Object }) => {}\n// Message: Unexpected use of weak type \"Object\"\n\n(foo: any[]) => {}\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = any\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = Function\n// Message: Unexpected use of weak type \"Function\"\n\ntype Foo = { a: any }\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = { a: Object }\n// Message: Unexpected use of weak type \"Object\"\n\ntype Foo = { (a: Object): string }\n// Message: Unexpected use of weak type \"Object\"\n\ntype Foo = { (a: string): Function }\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing: any) {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing: Object) {}\n// Message: Unexpected use of weak type \"Object\"\n\nvar foo: Function\n// Message: Unexpected use of weak type \"Function\"\n\nvar foo: Object\n// Message: Unexpected use of weak type \"Object\"\n\nclass Foo { props: any }\n// Message: Unexpected use of weak type \"any\"\n\nclass Foo { props: Object }\n// Message: Unexpected use of weak type \"Object\"\n\nvar foo: any\n// Message: Unexpected use of weak type \"any\"\n\n// Options: [{\"Function\":false}]\ntype X = any; type Y = Function; type Z = Object\n// Message: Unexpected use of weak type \"any\"\n// Message: Unexpected use of weak type \"Object\"\n\n// Options: [{\"Object\":false,\"any\":false}]\ntype X = any; type Y = Function; type Z = Object\n// Message: Unexpected use of weak type \"Function\"\n```\n\nThe following patterns are not considered problems:\n\n```js\nfunction foo(thing): string {}\n\nfunction foo(thing): Promise<string> {}\n\nfunction foo(thing): Promise<Promise<string>> {}\n\n(foo?: string) => {}\n\n(foo: ?string) => {}\n\n(foo: { a: string }) => {}\n\n(foo: { a: ?string }) => {}\n\n(foo: string[]) => {}\n\ntype Foo = string\n\ntype Foo = { a: string }\n\ntype Foo = { (a: string): string }\n\nfunction foo(thing: string) {}\n\nvar foo: string\n\nclass Foo { props: string }\n\n// Options: [{\"Object\":false,\"any\":false}]\ntype X = any; type Y = Object\n\n// Options: [{\"Function\":false}]\ntype X = Function\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-parameter-type\"></a>\n### <code>require-parameter-type</code>\n\nRequires that all function parameters have type annotations.\n\n<a name=\"eslint-plugin-flowtype-rules-require-parameter-type-options\"></a>\n#### Options\n\nYou can skip all arrow functions by providing the `excludeArrowFunctions` option with `true`.\n\nAlternatively, you can want to exclude only concise arrow functions (e.g. `x => x * 2`). Provide `excludeArrowFunctions` with `expressionsOnly` for this.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-parameter-type\": [\n            2,\n            {\n              \"excludeArrowFunctions\": true\n            }\n        ]\n    }\n}\n\n{\n    \"rules\": {\n        \"flowtype/require-parameter-type\": [\n            2,\n            {\n              \"excludeArrowFunctions\": \"expressionsOnly\"\n            }\n        ]\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":true}]\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n\n(foo = 'FOO') => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n(...foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n({foo}) => {}\n// Message: Missing \"{foo}\" parameter type annotation.\n\n([foo]) => {}\n// Message: Missing \"[foo]\" parameter type annotation.\n\n({foo = 1} = {}) => {}\n// Message: Missing \"{foo = 1}\" parameter type annotation.\n\n// @flow\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo: string) => {}\n\n(foo: string = 'FOO') => {}\n\n(...foo: string) => {}\n\n({foo}: {foo: string}) => {}\n\n([foo]: Array) => {}\n\n(foo) => {}\n\n// Options: [{\"excludeArrowFunctions\":true}]\n(foo) => {}\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n(foo) => 3\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-return-type\"></a>\n### <code>require-return-type</code>\n\nRequires that functions have return type annotation.\n\n<a name=\"eslint-plugin-flowtype-rules-require-return-type-options\"></a>\n#### Options\n\nYou can skip all arrow functions by providing the `excludeArrowFunctions` option with `true`.\n\nAlternatively, you can want to exclude only concise arrow function (e.g. `() => 2`). Provide `excludeArrowFunctions` with `expressionsOnly` for this.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"excludeArrowFunctions\": true\n            }\n        ]\n    }\n}\n\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"excludeArrowFunctions\": \"expressionsOnly\"\n            }\n        ]\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\n(foo) => { return \"foo\"; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\n(foo) => { return \"foo\"; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\n(foo) => \"foo\"\n// Message: Missing return type annotation.\n\n(foo) => ({})\n// Message: Missing return type annotation.\n\n(foo): undefined => { return; }\n// Message: Must not annotate undefined return type.\n\n(foo): void => { return; }\n// Message: Must not annotate undefined return type.\n\n(foo): undefined => { return undefined; }\n// Message: Must not annotate undefined return type.\n\n(foo): void => { return void 0; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): undefined => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): void => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): undefined => { return undefined; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return undefined; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return void 0; }\n// Message: Must annotate undefined return type.\n\n// @flow\n(foo) => { return 1; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n// @flow\n (foo) => { return undefined; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\"]\nasync () => { return 2; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync () => {}\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function x() {}\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\nasync () => { return; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\nfunction* x() {}\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n() => { return 3; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nasync () => { return 4; }\n// Message: Missing return type annotation.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo): string => {}\n\n// Options: [\"always\"]\n(foo): string => {}\n\n(foo) => { return; }\n\n(foo): Object => ( {} )\n\n(foo) => { return undefined; }\n\n(foo) => { return void 0; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): undefined => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): void => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return void 0; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): undefined => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): void => { return void 0; }\n\n// Options: [\"always\"]\n(foo) => { return 1; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function doThing(): Promise<void> {}\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nfunction* doThing(): Generator<number, void, void> { yield 2; }\n\nasync (foo): Promise<number> => { return 3; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => 3\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => { return 4; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => undefined\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\",\"excludeArrowFunctions\":true}]\n() => undefined\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\",\"excludeArrowFunctions\":true}]\n() => { return undefined; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n() => 3\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nasync () => 3\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-valid-file-annotation\"></a>\n### <code>require-valid-file-annotation</code>\n\nThis rule validates Flow file annotations.\n\nThis rule can optionally report missing or missed placed annotations, common typos (e.g. `// @floww`), and enforce a consistant annotation style.\n\n<a name=\"eslint-plugin-flowtype-rules-require-valid-file-annotation-options\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"never\"` (default): Never report files that are missing an `@flow` annotation.\n* `\"always\"`: Always report files that are missing an `@flow` annotation\n\nThis rule has an object option:\n\n* `\"annotationStyle\"` - Enforce a consistant file annotation style.\n    * `\"none\"` (default): Either annotation style is accepted.\n    * `\"line\"`: Require single line annotations (i.e. `// @flow`).\n    * `\"block\"`: Require block annotations (i.e. `/* @flow */`).\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-valid-file-annotation\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n\n{\n  \"rules\": {\n    \"flowtype/require-valid-file-annotation\": [\n      2,\n      \"always\", {\n        \"annotationStyle\": \"block\"\n      }\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\n;// @flow\n// Message: Flow file annotation not at the top of the file.\n\n;\n// @flow\n// Message: Flow file annotation not at the top of the file.\n\n// @Flow\n// Message: Malformed flow file annotation.\n\n// @floweeeeeee\n// Message: Malformed flow file annotation.\n\n// @NoFlow\n// Message: Malformed flow file annotation.\n\n// @nofloweeeeeee\n// Message: Malformed flow file annotation.\n\n// Options: [\"always\"]\na;\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\",{\"annotationStyle\":\"line\"}]\n/* @flow */\n// Message: Flow file annotation style must be `// @flow`\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n// @flow\n// Message: Flow file annotation style must be `/* @flow */`\n```\n\nThe following patterns are not considered problems:\n\n```js\na;\n\n// @flow\na;\n\n//@flow\na;\n\n//**@flow\na;\n\n/* foo @flow bar */\na;\n\n\n\n// @flow\na;\n\n// @flow\n// @FLow\n\n// @noflow\na;\n\n// Options: [\"always\"]\na;\n\n// Options: [\"always\",{\"annotationStyle\":\"line\"}]\n// @flow\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n/* @flow */\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-semi\"></a>\n### <code>semi</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent use of semicolons after type aliases.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a semicolon after a type alias. If it is `'always'` then a problem is raised when there is no semicolon after a type alias.\n\nThe default value is `'always'`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: []\ntype FooType = {}\n// Message: Missing semicolon.\n\n// Options: [\"always\"]\ntype FooType = {}\n// Message: Missing semicolon.\n\n// Options: [\"never\"]\ntype FooType = {};\n// Message: Extra semicolon.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = {};\n\n// Options: [\"always\"]\ntype FooType = {};\n\n// Options: [\"always\"]\ntype FooType = { a: number;\n b: string;\n };\n\n// Options: [\"never\"]\ntype FooType = { a: number;\n b: string;\n }\n\n// Options: [\"never\"]\ntype FooType = {}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-sort-keys\"></a>\n### <code>sort-keys</code>\n\nEnforces sorting of Object annotations.\n\nThis rule mirrors ESlint's [sort-keys](http://eslint.org/docs/rules/sort-keys) rule.\n\n<a name=\"eslint-plugin-flowtype-rules-sort-keys-options\"></a>\n#### Options\n\nThe first option specifies sort order.\n\n* `\"asc\"` (default) - enforce ascending sort order.\n* `\"desc\"` - enforce descending sort order.\n\nThe second option takes an object with two possible properties.\n\n* `caseSensitive` - if `true`, enforce case-sensitive sort order. Default is `true`.\n* `natural` - if `true`, enforce [natural sort order](https://en.wikipedia.org/wiki/Natural_sort_order). Default is `false`.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-keys\": [\n      2,\n      \"asc\", {\n        \"caseSensitive\": true,\n        \"natural\": false\n      }\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype FooType = { a: number, c: number, b: string }\n// Message: Expected type annotations to be in ascending order. \"b\" should be before \"c\".\n\ntype FooType = { a: number, b: number, C: number }\n// Message: Expected type annotations to be in ascending order. \"C\" should be before \"b\".\n\ntype FooType = { 1: number, 2: number, 10: number }\n// Message: Expected type annotations to be in ascending order. \"10\" should be before \"2\".\n\n// Options: [\"desc\"]\ntype FooType = { a: number, b: number }\n// Message: Expected type annotations to be in descending order. \"b\" should be before \"a\".\n\n// Options: [\"desc\"]\ntype FooType = { C: number, b: number, a: string }\n// Message: Expected type annotations to be in descending order. \"b\" should be before \"C\".\n\n// Options: [\"desc\"]\ntype FooType = { 10: number, 2: number, 1: number }\n// Message: Expected type annotations to be in descending order. \"2\" should be before \"10\".\n\n// Options: [\"asc\",{\"caseSensitive\":false}]\ntype FooType = { a: number, c: number, C: number, b: string }\n// Message: Expected type annotations to be in insensitive ascending order. \"b\" should be before \"C\".\n\n// Options: [\"asc\",{\"caseSensitive\":false}]\ntype FooType = { a: number, C: number, c: number, b: string }\n// Message: Expected type annotations to be in insensitive ascending order. \"b\" should be before \"c\".\n\n// Options: [\"asc\",{\"natural\":true}]\ntype FooType = { 1: number, 10: number, 2: boolean }\n// Message: Expected type annotations to be in natural ascending order. \"2\" should be before \"10\".\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = { a: number }\n\ntype FooType = { a: number, b: number, c: (boolean | number) }\n\ntype FooType = { C: number, a: string, b: foo }\n\ntype FooType = { 1: number, 10: number, 2: boolean }\n\n// Options: [\"desc\"]\ntype FooType = { c: number, b: number, a: number }\n\n// Options: [\"desc\"]\ntype FooType = { b: string, a: {}, C: number }\n\n// Options: [\"desc\"]\ntype FooType = { 2: number, 10: number, 1: boolean }\n\n// Options: [\"asc\",{\"caseSensitive\":false}]\ntype FooType = { a: number, b: number, c: number, C: number }\n\n// Options: [\"asc\",{\"caseSensitive\":false}]\ntype FooType = { a: number, b: number, C: number, c: number }\n\n// Options: [\"asc\",{\"natural\":true}]\ntype FooType = { 1:number, 2: number, 10: number }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-after-type-colon\"></a>\n### <code>space-after-type-colon</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing after the type annotation colon.\n\nThis rule takes one argument. If it is `'always'` then a problem is raised when there is no space after the type annotation colon. If it is `'never'` then a problem is raised when there is a space after the type annotation colon. The default value is `'always'`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"never\"]\n(foo: string) => {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:  string) => {}\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:(() => void)) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(foo: (() => void)) => {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:  (() => void)) => {}\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n({ lorem, ipsum, dolor } :   SomeType) => {}\n// Message: There must be 1 space after \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\n(foo:{ a: string, b: number }) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n({ a, b } :{ a: string, b: number }) => {}\n// Message: There must be a space after \"{ a, b }\" parameter type annotation colon.\n\n([ a, b ] :string[]) => {}\n// Message: There must be a space after \"[ a, b ]\" parameter type annotation colon.\n\n(i?:number) => {}\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\n(i?:  number) => {}\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(i?: number) => {}\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\n// Options: [\"always\"]\n():Object => {}\n// Message: There must be a space after return type colon.\n\n// Options: [\"never\"]\n(): Object => {}\n// Message: There must be no space after return type colon.\n\n// Options: [\"always\"]\n():  Object => {}\n// Message: There must be 1 space after return type colon.\n\n// Options: [\"always\"]\n():(() => void) => {}\n// Message: There must be a space after return type colon.\n\n// Options: [\"never\"]\n(): (() => void) => {}\n// Message: There must be no space after return type colon.\n\n// Options: [\"always\"]\n():  (() => void) => {}\n// Message: There must be 1 space after return type colon.\n\n// Options: [\"never\"]\nexport default function (foo: string) {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\nfunction foo (foo: string) {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:string) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\nfunction foo (foo:string) {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\nasync function foo({ lorem, ipsum, dolor }:SomeType) {}\n// Message: There must be a space after \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\nfunction x(i?:number) {}\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\nfunction x(i?:  number) {}\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\nfunction x(i?: number) {}\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\ntype X = (foo:number) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype X = (foo: number) => string\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:  number) => string\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:?number) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:(number)) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:((number))) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:  ((number))) => string\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype X = (foo: ((number))) => string\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:?(number)) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype TArrayPredicate = (el: T, i?:number) => boolean\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\ntype TArrayPredicate = (el: T, i?:  number) => boolean\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype TArrayPredicate = (el:T, i?: number) => boolean\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\nclass X { foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { foo:?string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { foo: ?string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static foo:number }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static foo: number }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static foo :number }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static foo : number }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\ndeclare class X { static foo:number }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ndeclare class X { static foo: number }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ndeclare class X { static foo :number }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ndeclare class X { static foo : number }\n// Message: There must be no space after \"foo\" type annotation colon.\n\nclass X { +foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\nclass X { +foo:  string }\n// Message: There must be 1 space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { +foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static +foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\nclass X { static +foo:  string }\n// Message: There must be 1 space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static +foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\ntype X = { foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { foo:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\ntype X = { foo?:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo?: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { foo?:?string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { foo?:  ?string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\ntype Foo = { barType:(string | () => void) }\n// Message: There must be a space after \"barType\" type annotation colon.\n\ntype Foo = { barType:(((string | () => void))) }\n// Message: There must be a space after \"barType\" type annotation colon.\n\n// Options: [\"never\"]\ntype Foo = { barType: (string | () => void) }\n// Message: There must be no space after \"barType\" type annotation colon.\n\ntype Foo = { barType:  (string | () => void) }\n// Message: There must be 1 space after \"barType\" type annotation colon.\n\ntype Foo = { barType:  ((string | () => void)) }\n// Message: There must be 1 space after \"barType\" type annotation colon.\n\ntype X = { get:() => A; }\n// Message: There must be a space after \"get\" type annotation colon.\n\ntype X = { get:<X>() => A; }\n// Message: There must be a space after \"get\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { get: () => A; }\n// Message: There must be no space after \"get\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { get: <X>() => A; }\n// Message: There must be no space after \"get\" type annotation colon.\n\ntype X = { get:  () => A; }\n// Message: There must be 1 space after \"get\" type annotation colon.\n\ntype X = { get:  <X>() => A; }\n// Message: There must be 1 space after \"get\" type annotation colon.\n\ntype X = { +foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { +foo:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { +foo?:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { +foo?:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo?: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\nconst x = ({}: {})\n// Message: There must be no space after type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:{})\n// Message: There must be a space after type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:  {})\n// Message: There must be 1 space after type cast colon.\n\n// Options: [\"never\"]\n((x): (string))\n// Message: There must be no space after type cast colon.\n\n// Options: [\"always\"]\n((x):(string))\n// Message: There must be a space after type cast colon.\n\n// Options: [\"always\"]\n((x):  (string))\n// Message: There must be 1 space after type cast colon.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo) => {}\n\n(foo: string) => {}\n\n(foo: (string|number)) => {}\n\n// Options: [\"never\"]\n(foo:string) => {}\n\n// Options: [\"always\"]\n(foo: string) => {}\n\n// Options: [\"never\"]\n(foo:(() => void)) => {}\n\n// Options: [\"always\"]\n(foo: (() => void)) => {}\n\n({ lorem, ipsum, dolor }: SomeType) => {}\n\n(foo: { a: string, b: number }) => {}\n\n({ a, b }: ?{ a: string, b: number }) => {}\n\n([ a, b ]: string[]) => {}\n\n(i?: number) => {}\n\n// Options: [\"never\"]\n(i?:number) => {}\n\n// Options: [\"never\"]\n():Object => {}\n\n// Options: [\"always\"]\n(): Object => {}\n\n// Options: [\"never\"]\n():(number | string) => {}\n\n// Options: [\"always\"]\n(): (number | string) => {}\n\n// Options: [\"never\"]\n():number|string => {}\n\n// Options: [\"always\"]\n(): number|string => {}\n\n// Options: [\"never\"]\n():(() => void) => {}\n\n// Options: [\"always\"]\n(): (() => void) => {}\n\n// Options: [\"never\"]\n():( () => void ) => {}\n\n// Options: [\"always\"]\n(): ( () => void ) => {}\n\n(): { a: number, b: string } => {}\n\n// Options: [\"never\"]\n() :{ a:number, b:string } => {}\n\nfunction x(foo: string) {}\n\nclass Foo { constructor(foo: string) {} }\n\n// Options: [\"never\"]\nfunction x(foo:string) {}\n\n// Options: [\"never\"]\nclass Foo { constructor(foo:string) {} }\n\nasync function foo({ lorem, ipsum, dolor }: SomeType) {}\n\nfunction x({ a, b }: { a: string, b: number }) {}\n\nfunction x(i?: number) {}\n\n// Options: [\"never\"]\nfunction x(i?:number) {}\n\ntype X = (foo: number) => string;\n\ntype X = (foo : number) => string;\n\ntype X = (foo: ?number) => string;\n\ntype X = (foo? : ?number) => string;\n\ntype X = (foo: ?{ x: number }) => string;\n\n// Options: [\"never\"]\ntype X = (foo:number) => string;\n\n// Options: [\"never\"]\ntype X = (foo:?{ x:number }) => string;\n\ntype X = (foo: (number)) => string\n\ntype X = (foo: ((number))) => string\n\n// Options: [\"never\"]\ntype X = (foo:((number))) => string\n\ntype X = ?(foo: ((number))) => string\n\n// Options: [\"never\"]\ntype X = ?(foo:((number))) => string\n\ntype TArrayPredicate = (el: T, i?: number) => boolean\n\n// Options: [\"never\"]\ntype TArrayPredicate = (el:T, i?:number) => boolean\n\nclass Foo { bar }\n\nclass Foo { bar = 3 }\n\nclass Foo { bar: string }\n\nclass Foo { bar: ?string }\n\n// Options: [\"never\"]\nclass Foo { bar:string }\n\n// Options: [\"never\"]\nclass Foo { bar:?string }\n\nclass X { static foo : number }\n\n// Options: [\"never\"]\nclass X { static foo :number }\n\ndeclare class X { static foo : number }\n\n// Options: [\"never\"]\ndeclare class X { static foo :number }\n\nclass X { +foo: string }\n\nclass X { static +foo: string }\n\n// Options: [\"never\"]\nclass X { +foo:string }\n\n// Options: [\"never\"]\nclass X { static +foo:string }\n\ntype X = { foo: string }\n\n// Options: [\"never\"]\ntype X = { foo:string }\n\ntype X = { foo?: string }\n\ntype X = { foo?: ?string }\n\n// Options: [\"never\"]\ntype X = { foo?:?string }\n\ntype Foo = { barType: (string | () => void) }\n\ntype Foo = { barType: ((string | () => void)) }\n\n// Options: [\"never\"]\ntype Foo = { barType:(string | () => void) }\n\n// Options: [\"never\"]\ntype Foo = { barType:((string | () => void)) }\n\ntype X = { get(): A; }\n\ntype X = { get<X>(): A; }\n\n// Options: [\"never\"]\ntype X = { get(): A; }\n\n// Options: [\"never\"]\ntype X = { get<X>(): A; }\n\ntype X = { get: () => A; }\n\ntype X = { get: <X>() => A; }\n\n// Options: [\"never\"]\ntype X = { get:() => A; }\n\n// Options: [\"never\"]\ntype X = { get:<X>() => A; }\n\ntype X = { +foo: string }\n\ntype X = { +foo?: string }\n\n// Options: [\"never\"]\ntype X = { +foo:string }\n\n// Options: [\"never\"]\ntype X = { +foo?:string }\n\n// Options: [\"never\"]\nconst x = ({}:{})\n\n// Options: [\"always\"]\nconst x = ({}: {})\n\n// Options: [\"never\"]\n((x):(string))\n\n// Options: [\"always\"]\n((x): (string))\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-before-generic-bracket\"></a>\n### <code>space-before-generic-bracket</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing before the opening `<` of generic type annotation parameters.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a space before the `<`. If it is `'always'` then a problem is raised when there is no space before the `<`.\n\nThe default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = Promise <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\n// Options: [\"never\"]\ntype X = Promise <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\ntype X = Promise  <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\n// Options: [\"always\"]\ntype X = Promise<string>\n// Message: There must be a space before \"Promise\" generic type annotation bracket\n\n// Options: [\"always\"]\ntype X = Promise  <string>\n// Message: There must be one space before \"Promise\" generic type annotation bracket\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Promise<string>\n\n// Options: [\"always\"]\ntype X = Promise <string>\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-before-type-colon\"></a>\n### <code>space-before-type-colon</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing before the type annotation colon.\n\nThis rule takes one argument. If it is `'always'` then a problem is raised when there is no space before the type annotation colon. If it is `'never'` then a problem is raised when there is a space before the type annotation colon. The default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"never\"]\n(foo : string) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(foo ? : string) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo  : string) => {}\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo?: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo ?  : string) => {}\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo  ?: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n({ lorem, ipsum, dolor } : SomeType) => {}\n// Message: There must be no space before \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\n(foo : { a: string, b: number }) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n({ a, b } : { a: string, b: number }) => {}\n// Message: There must be no space before \"{ a, b }\" parameter type annotation colon.\n\n([ a, b ] : string[]) => {}\n// Message: There must be no space before \"[ a, b ]\" parameter type annotation colon.\n\nfunction x(foo : string) {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nfunction x(foo: string) {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nvar x = function (foo : string) {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nvar x = function (foo: string) {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nclass Foo { constructor(foo : string ) {} }\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nclass Foo { constructor(foo: string ) {} }\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nasync function foo({ lorem, ipsum, dolor } : SomeType) {}\n// Message: There must be no space before \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\ntype X = (foo :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo:string) => string;\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo  :string) => string;\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\ntype X = (foo? :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\ntype X = (foo?     :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo?:string) => string;\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\ntype X = (foo? :?string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\nclass X { foo :string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\nclass X { foo :?string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { foo: ?string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\nclass X { static foo : number }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\nclass X { static foo :number }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static foo: number }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static foo:number }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\ndeclare class Foo { static bar :number; }\n// Message: There must be no space before \"bar\" type annotation colon.\n\ndeclare class Foo { static bar : number; }\n// Message: There must be no space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\ndeclare class Foo { static bar:number; }\n// Message: There must be a space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\ndeclare class Foo { static bar: number; }\n// Message: There must be a space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\nclass X { +foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { +foo  : string }\n// Message: There must be 1 space before \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { +foo : string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static +foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static +foo  : string }\n// Message: There must be 1 space before \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static +foo : string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\ntype X = { foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\ntype X = { foo? : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo?  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo   ?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo?  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo? : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\nconst x = ({} :{})\n// Message: There must be no space before type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:{})\n// Message: There must be a space before type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}  :{})\n// Message: There must be 1 space before type cast colon.\n\n// Options: [\"never\"]\n((x) : string)\n// Message: There must be no space before type cast colon.\n\n// Options: [\"always\"]\n((x): string)\n// Message: There must be a space before type cast colon.\n\n// Options: [\"always\"]\n((x)  : string)\n// Message: There must be 1 space before type cast colon.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo) => {}\n\n(foo: string) => {}\n\n(foo?: string) => {}\n\n(foo ?: string) => {}\n\n// Options: [\"never\"]\n(foo: string) => {}\n\n// Options: [\"always\"]\n(foo : string) => {}\n\n// Options: [\"always\"]\n(foo? : string) => {}\n\n// Options: [\"always\"]\n(foo ? : string) => {}\n\n// Options: [\"always\"]\n(foo  ? : string) => {}\n\n({ lorem, ipsum, dolor }: SomeType) => {}\n\n(foo: { a: string, b: number }) => {}\n\n({ a, b }: ?{ a: string, b: number }) => {}\n\n(): { a: number, b: string } => {}\n\n// Options: [\"always\"]\n() : { a : number, b : string } => {}\n\n([ a, b ]: string[]) => {}\n\nfunction x(foo: string) {}\n\n// Options: [\"always\"]\nfunction x(foo : string) {}\n\nvar x = function (foo: string) {}\n\n// Options: [\"always\"]\nvar x = function (foo : string) {}\n\nclass X { foo({ bar }: Props = this.props) {} }\n\nclass Foo { constructor(foo: string ) {} }\n\n// Options: [\"always\"]\nclass Foo { constructor(foo : string ) {} }\n\nasync function foo({ lorem, ipsum, dolor }: SomeType) {}\n\nfunction x({ a, b }: { a: string, b: number }) {}\n\ntype X = (foo:string) => number;\n\ntype X = (foo: string) => number;\n\ntype X = (foo: ?string) => number;\n\ntype X = (foo?: string) => number;\n\ntype X = (foo?: ?string) => number;\n\ntype X = (foo   ?: string) => number;\n\n// Options: [\"always\"]\ntype X = (foo? : string) => number\n\n// Options: [\"always\"]\ntype X = (foo? : ?string) => number\n\nclass Foo { bar }\n\nclass Foo { bar = 3 }\n\nclass Foo { bar: string }\n\nclass Foo { bar: ?string }\n\nclass Foo { bar:?string }\n\n// Options: [\"always\"]\nclass Foo { bar : string }\n\nclass X { static foo:number }\n\nclass X { static foo: number }\n\n// Options: [\"always\"]\nclass X { static foo :number }\n\n// Options: [\"always\"]\nclass X { static foo : number }\n\ndeclare class Foo { static bar:number; }\n\n// Options: [\"always\"]\ndeclare class Foo { static bar :number; }\n\ndeclare class Foo { static bar: number; }\n\n// Options: [\"always\"]\ndeclare class Foo { static bar : number; }\n\nclass X { +foo: string }\n\nclass X { static +foo: string }\n\n// Options: [\"always\"]\nclass X { +foo : string }\n\n// Options: [\"always\"]\nclass X { static +foo : string }\n\ntype X = { foo: string }\n\n// Options: [\"always\"]\ntype X = { foo : string }\n\ntype X = { foo?: string }\n\ntype X = { foo   ?: string }\n\n// Options: [\"always\"]\ntype X = { foo? : string }\n\ntype X = { +foo: string }\n\ntype X = { +foo?: string }\n\n// Options: [\"always\"]\ntype X = { +foo : string }\n\n// Options: [\"always\"]\ntype X = { +foo? : string }\n\n// Options: [\"never\"]\nconst x = ({}:{})\n\n// Options: [\"always\"]\nconst x = ({} :{})\n\n// Options: [\"never\"]\n((x): string)\n\n// Options: [\"always\"]\n((x) : string)\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-type-id-match\"></a>\n### <code>type-id-match</code>\n\nEnforces a consistent naming pattern for type aliases.\n\n<a name=\"eslint-plugin-flowtype-rules-type-id-match-options\"></a>\n#### Options\n\nThis rule needs a text RegExp to operate with Its signature is as follows:\n\n```js\n{\n    \"rules\": {\n        \"flowtype/type-id-match\": [\n            2,\n            \"^([A-Z][a-z0-9]*)+Type$\"\n        ]\n    }\n}\n```\n\n`'^([A-Z][a-z0-9]*)+Type$'` is the default pattern.\n\nThe following patterns are considered problems:\n\n```js\ntype foo = {};\n// Message: Type identifier 'foo' does not match pattern '/^([A-Z][a-z0-9]*)+Type$/'.\n\n// Options: [\"^foo$\"]\ntype FooType = {};\n// Message: Type identifier 'FooType' does not match pattern '/^foo$/'.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = {};\n\n// Options: [\"^foo$\"]\ntype foo = {};\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-union-intersection-spacing\"></a>\n### <code>union-intersection-spacing</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing around union and intersection type separators (`|` and `&`).\n\nThis rule takes one argument. If it is `'always'` then a problem is raised when there is no space around the separator. If it is `'never'` then a problem is raised when there is a space around the separator.\n\nThe default value is `'always'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = string| number;\n// Message: There must be a space before union type annotation separator\n\n// Options: [\"always\"]\ntype X = string| number;\n// Message: There must be a space before union type annotation separator\n\ntype X = string |number;\n// Message: There must be a space after union type annotation separator\n\ntype X = string|number;\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = {x: string}|{y: number};\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = string | number |boolean;\n// Message: There must be a space after union type annotation separator\n\ntype X = string|number|boolean;\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = (string)| number;\n// Message: There must be a space before union type annotation separator\n\ntype X = ((string))|(number | foo);\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\n// Options: [\"never\"]\ntype X = string |number;\n// Message: There must be no space before union type annotation separator\n\n// Options: [\"never\"]\ntype X = string| number;\n// Message: There must be no space after union type annotation separator\n\ntype X = string& number;\n// Message: There must be a space before intersection type annotation separator\n\n// Options: [\"always\"]\ntype X = string& number;\n// Message: There must be a space before intersection type annotation separator\n\ntype X = string &number;\n// Message: There must be a space after intersection type annotation separator\n\ntype X = {x: string}&{y: number};\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string&number;\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string & number &boolean;\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string&number&boolean;\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = (string)& number;\n// Message: There must be a space before intersection type annotation separator\n\ntype X = ((string))&(number & foo);\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\n// Options: [\"never\"]\ntype X = string &number;\n// Message: There must be no space before intersection type annotation separator\n\n// Options: [\"never\"]\ntype X = string& number;\n// Message: There must be no space after intersection type annotation separator\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = string | number;\n\ntype X = string | number | boolean;\n\ntype X = (string) | number;\n\ntype X = ((string)) | (number | foo);\n\n// Options: [\"never\"]\ntype X = string|number\n\ntype X =\n| string\n| number\n\nfunction x() {\ntype X =\n| string\n| number\n}\n\ntype X = string & number;\n\ntype X = string & number & boolean;\n\ntype X = (string) & number;\n\ntype X = ((string)) & (number & foo);\n\n// Options: [\"never\"]\ntype X = string&number\n\ntype X =\n& string\n& number\n\nfunction x() {\ntype X =\n& string\n& number\n}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-use-flow-type\"></a>\n### <code>use-flow-type</code>\n\nMarks Flow [type alias](https://flowtype.org/docs/type-aliases.html) declarations as used.\n\nUsed to suppress [`no-unused-vars`](http://eslint.org/docs/rules/no-unused-vars) errors that are triggered by type aliases.\n\nThe following patterns are not considered problems:\n\n```js\ndeclare class A {}\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare function A(): Y\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare module A {}\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare module A { declare var a: Y }\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare var A: Y\n// Additional rules: {\"no-unused-vars\":1}\n\nimport type A from \"a\"; (function<T: A>(): T {})\n// Additional rules: {\"no-unused-vars\":1}\n\n(function<T: A>(): T {}); import type A from \"a\"\n// Additional rules: {\"no-unused-vars\":1}\n\nimport type {A} from \"a\"; (function<T: A>(): T {})\n// Additional rules: {\"no-unused-vars\":1}\n\n(function<T: A>(): T {}); import type {A} from \"a\"\n// Additional rules: {\"no-unused-vars\":1}\n\n(function<T: A>(): T {}); import type {a as A} from \"a\"\n// Additional rules: {\"no-unused-vars\":1}\n\ntype A = {}; function x<Y: A>(i: Y) { i }; x()\n// Additional rules: {\"no-unused-vars\":1}\n\nfunction x<Y: A>(i: Y) { i }; type A = {}; x()\n// Additional rules: {\"no-unused-vars\":1}\n\ntype A = {}; function x<Y: A.B.C>(i: Y) { i }; x()\n// Additional rules: {\"no-unused-vars\":1}\n\nfunction x<Y: A.B.C>(i: Y) { i }; type A = {}; x()\n// Additional rules: {\"no-unused-vars\":1}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-valid-syntax\"></a>\n### <code>valid-syntax</code>\n\n**Deprecated** Babylon (the Babel parser) v6.10.0 fixes parsing of the invalid syntax this plugin warned against.\n\nChecks for simple Flow syntax errors.\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gajus/eslint-plugin-flowtype.git"
  },
  "scripts": {
    "build": "babel ./src --out-dir ./dist --copy-files",
    "commitmsg": "conventional-changelog-lint -e",
    "create-index": "create-index ./src --update-index",
    "documentation": "gitdown ./.README/README.md --output-file ./README.md; npm run documentation-add-assertions",
    "documentation-add-assertions": "babel-node ./bin/readmeAssertions",
    "format-json": "jsonlint --sort-keys --in-place --indent '  ' ./src/configs/recommended.json && echo '' >> ./src/configs/recommended.json",
    "lint": "eslint ./src ./tests",
    "precommit": "npm run lint && npm run test && npm run format-json",
    "test": "mocha --compilers js:babel-register ./tests/rules/index.js"
  },
  "version": "2.21.0"
}
